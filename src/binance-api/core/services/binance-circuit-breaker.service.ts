import { Injectable, Logger } from '@nestjs/common';
import { BanInfo, CircuitState } from '../interfaces/binance-response.interface';

@Injectable()
export class BinanceCircuitBreakerService {
    private readonly logger = new Logger(BinanceCircuitBreakerService.name);

    private state: CircuitState = CircuitState.CLOSED;
    private banInfo: BanInfo | null = null;
    private failureCount: number = 0;
    private lastFailureTime: number = 0;

    // Configuraci√≥n
    private readonly FAILURE_THRESHOLD = 3; // Despu√©s de 3 fallos consecutivos, abrir circuito
    private readonly TIMEOUT_WINDOW = 60000; // 1 minuto para resetear conteo de fallos
    private readonly HALF_OPEN_RETRY_AFTER = 30000; // Intentar despu√©s de 30s si no hay ban info

    /**
     * Verifica si se puede hacer una llamada a Binance
     */
    canMakeRequest(): boolean {
        // Si hay ban expl√≠cito, verificar si expir√≥
        if (this.banInfo) {
            const now = Date.now();
            if (now < this.banInfo.until) {
                const remainingMs = this.banInfo.until - now;
                const remainingMin = Math.ceil(remainingMs / 60000);
                this.logger.warn(
                    `üö´ Binance bloqueado: ${this.banInfo.reason}. ` +
                    `Se desbloquear√° en ~${remainingMin} minutos`
                );
                return false;
            } else {
                // Ban expir√≥, intentar de nuevo
                this.logger.log('‚úÖ Ban de Binance expirado, intentando reconectar...');
                this.state = CircuitState.HALF_OPEN;
                this.banInfo = null;
                this.failureCount = 0;
                return true;
            }
        }

        // L√≥gica del circuito
        switch (this.state) {
            case CircuitState.CLOSED:
                return true;

            case CircuitState.OPEN:
                // Verificar si pas√≥ suficiente tiempo para intentar de nuevo
                const timeSinceLastFailure = Date.now() - this.lastFailureTime;
                if (timeSinceLastFailure > this.HALF_OPEN_RETRY_AFTER) {
                    this.logger.log('üîÑ Circuit HALF_OPEN - intentando request de prueba...');
                    this.state = CircuitState.HALF_OPEN;
                    return true;
                }
                this.logger.warn(`‚ö†Ô∏è Circuit OPEN - bloqueando requests a Binance`);
                return false;

            case CircuitState.HALF_OPEN:
                // Solo permitir un request de prueba
                return true;

            default:
                return true;
        }
    }

    /**
     * Registra un √©xito en la llamada a Binance
     */
    recordSuccess(): void {
        if (this.state === CircuitState.HALF_OPEN) {
            this.logger.log('‚úÖ Request exitoso - Circuit CLOSED');
            this.state = CircuitState.CLOSED;
        }
        this.failureCount = 0;
        this.lastFailureTime = 0;
    }

    /**
     * Registra un error de Binance y actualiza el estado del circuito
     */
    recordFailure(error: any): void {
        const now = Date.now();
        this.lastFailureTime = now;

        // Detectar error 429 (Rate Limit)
        if (error?.status === 429 || error?.response?.status === 429) {
            this.failureCount++;
            this.logger.error(
                `‚ùå Rate Limit 429 detectado (${this.failureCount}/${this.FAILURE_THRESHOLD})`
            );

            // Abrir circuito despu√©s del threshold
            if (this.failureCount >= this.FAILURE_THRESHOLD) {
                this.state = CircuitState.OPEN;
                this.logger.error('üî¥ Circuit OPEN - demasiados errores 429');
            }
            return;
        }

        // Detectar error 418 (IP Banned)
        if (error?.status === 418 || error?.response?.status === 418) {
            const data = error?.data || error?.response?.data;

            // Intentar extraer el timestamp del ban
            let banUntil = now + (30 * 24 * 60 * 60 * 1000); // Default: 30 d√≠as

            if (data?.msg) {
                const match = data.msg.match(/until (\d+)/);
                if (match) {
                    banUntil = parseInt(match[1]);
                }
            }

            this.banInfo = {
                until: banUntil,
                reason: data?.msg || 'IP banned by Binance'
            };

            this.state = CircuitState.OPEN;

            const banDate = new Date(banUntil).toLocaleString('es-AR', {
                timeZone: 'America/Argentina/Buenos_Aires'
            });

            this.logger.error(
                `üî¥üî¥üî¥ BAN 418 DETECTADO üî¥üî¥üî¥\n` +
                `Raz√≥n: ${this.banInfo.reason}\n` +
                `Se desbloquear√°: ${banDate}`
            );
            return;
        }

        // Otros errores (timeout, network, etc)
        this.failureCount++;
        this.logger.warn(`‚ö†Ô∏è Error en Binance (${this.failureCount}/${this.FAILURE_THRESHOLD})`);

        // Si hay muchos errores consecutivos en poco tiempo, abrir circuito
        if (this.failureCount >= this.FAILURE_THRESHOLD) {
            this.state = CircuitState.OPEN;
            this.logger.error('üî¥ Circuit OPEN - m√∫ltiples fallos consecutivos');
        }

        // Resetear conteo si pas√≥ mucho tiempo desde el √∫ltimo fallo
        const timeSinceLastFailure = now - this.lastFailureTime;
        if (timeSinceLastFailure > this.TIMEOUT_WINDOW) {
            this.failureCount = 1;
        }
    }

    /**
     * Obtiene el estado actual del circuito
     */
    getState(): {
        state: CircuitState;
        banInfo: BanInfo | null;
        failureCount: number;
        isBlocked: boolean;
    } {
        return {
            state: this.state,
            banInfo: this.banInfo,
            failureCount: this.failureCount,
            isBlocked: !this.canMakeRequest()
        };
    }

    /**
     * Fuerza el reseteo del circuito (para testing o admin)
     */
    reset(): void {
        this.state = CircuitState.CLOSED;
        this.banInfo = null;
        this.failureCount = 0;
        this.lastFailureTime = 0;
        this.logger.log('üîÑ Circuit Breaker reseteado manualmente');
    }
}